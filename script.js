   // Cat data for the game
   const originalGameData = {
    level1: {
        cats: [
            {
                image: "https://res.cloudinary.com/dvd1gjjou/image/upload/v1742466579/beluga_wrong_s6izdr.jpg",
                description: "แมวคนดังที่ไม่น่าดัง"
            },
            {
                image: "https://res.cloudinary.com/dvd1gjjou/image/upload/t_crop/v1742466579/stare_wrong_ctrdzd.jpg",
                description: "แมวตัวนี้อยู่ในมีมบ้อยบ่อย"
            },
            {
                image: "https://res.cloudinary.com/dvd1gjjou/image/upload/v1739025966/bean_correct_wfgxwp.jpg",
                description: "รุ่นนี้กระโดดไม่ได้"
            },
            {
                image: "https://res.cloudinary.com/dvd1gjjou/image/upload/t_crop/v1742466579/ai_wrong_lezne5.jpg",
                description: "นี่คือแมวจริงๆ"
            },
            {
                image: "https://res.cloudinary.com/dvd1gjjou/image/upload/t_crop/v1742466579/cry_wrong_i8egmh.jpg",
                description: "เคยสงสารแมวบ้างไหม"
            },
            {
                image: "https://res.cloudinary.com/dvd1gjjou/image/upload/t_crop/v1743402593/cat10_wrong_gmjvj6.jpg",
                description: "หะ"
            },
            {
                image: "https://res.cloudinary.com/dvd1gjjou/image/upload/t_22/v1743402594/bie_wrong_urxu3m.jpg",
                description: "อกหักรักคุณรักตุ้ดดีกว่าไหม"
            },
            {
                image: "https://res.cloudinary.com/dvd1gjjou/image/upload/t_crop/v1743402594/elephant_wrong_ywsptg.jpg",
                description: "แป้นๆๆๆๆๆๆๆๆ"
            },
            {
                image: "https://res.cloudinary.com/dvd1gjjou/image/upload/t_crop/v1743402594/cat9.wrong_nexrie.jpg",
                description: "เมี้ยว"
            },
            {
                image: "https://res.cloudinary.com/dvd1gjjou/image/upload/t_crop/v1743402595/cat8_wrong_jqhhtk.jpg",
                description: "แมวส้มโสด"
            },
            {
                image: "https://res.cloudinary.com/dvd1gjjou/image/upload/t_crop/v1743402595/cat-laughing_wrong_rvkr1i.jpg",
                description: "5565675773775675656757647"
            },
            {
                image: "https://res.cloudinary.com/dvd1gjjou/image/upload/t_crop/v1743402594/cat7_wrong_bsacnl.jpg",
                description: "4K"
            },
            {
                image: "https://res.cloudinary.com/dvd1gjjou/image/upload/t_crop/v1743402595/ronaldo_wrong_jg3qkc.png",
                description: "SIUUUUUUUUUUUUUUUUUUUUUU"
            },
            {
                image: "https://res.cloudinary.com/dvd1gjjou/image/upload/t_crop/v1743402595/caseoh_wrong_wtdlaq.jpg",
                description: "Mcdonalds"
            },
            {
                image: "https://res.cloudinary.com/dvd1gjjou/image/upload/t_crop/v1743402595/cat4_wrong_gjqoyu.jpg",
                description: "purrr"
            }
        ],
        correctCatIndex: 2  // The gray and white tuxedo cat
    },
    level2: {
        cats: [
            {
                image: "https://res.cloudinary.com/dvd1gjjou/image/upload/t_crop/v1742466580/mycat_right_xxihnf.jpg",
                description: "แมวก็หล่อได้นะ"
            },
            {
                image: "https://res.cloudinary.com/dvd1gjjou/image/upload/v1739025967/spiderman_wrong_cly0fi.jpg",
                description: "พี่อยากเป็นสไปเด้อแมน"
            },
            {
                image: "https://res.cloudinary.com/dvd1gjjou/image/upload/v1739025967/sleepy_wrong_rdqlth.jpg",
                description: "รูปแบบนี้แหละที่อยุ่ในเครื่องเพื่อน"
            },
            {
                image: "https://res.cloudinary.com/dvd1gjjou/image/upload/t_crop/v1742466579/baby_wrong_vamiij.jpg",
                description: "เหมือนพวกเด็กน้อย."
            },
            {
                image: "https://res.cloudinary.com/dvd1gjjou/image/upload/t_crop/v1742466875/sadge_wrong_gnvgpq.jpg",
                description: "อย่าไปคงอย่าไปเครียดอย่าไปสนใจอย่าซีเรียส"
            },
            {
                image: "https://res.cloudinary.com/dvd1gjjou/image/upload/t_crop/v1743402595/cat3_wrong_u65be6.jpg",
                description: "ขาวโอโม่"
            },
            {
                image: "https://res.cloudinary.com/dvd1gjjou/image/upload/t_crop/v1743402596/cat5_wrong_vf7knx.jpg",
                description: "สยามบอย"
            },
            {
                image: "https://res.cloudinary.com/dvd1gjjou/image/upload/t_crop/v1743402596/cat2_wrong_sbp72k.jpg",
                description: "แมวส้มก้มแล้วนอน"
            },
            {
                image: "https://res.cloudinary.com/dvd1gjjou/image/upload/t_crop/v1743402596/mrfresh_wrong_k1ick0.jpg",
                description: "Bombastic sideye"
            },
            {
                image: "https://res.cloudinary.com/dvd1gjjou/image/upload/t_crop/v1743402596/lebron_wrong_frevhi.png",
                description: "เเพะ"
            },
            {
                image: "https://res.cloudinary.com/dvd1gjjou/image/upload/t_crop/v1743402596/don_wrong_cizjpv.jpg",
                description: "bla bla bla ble ble ble blu blu blu hmhmhmhmhmh"
            },
            {
                image: "https://res.cloudinary.com/dvd1gjjou/image/upload/t_crop/v1743402596/cat1_wrong_nulxl7.jpg",
                description: "zzzzzzzzzzzzzzzzzzzzzz"
            },
            {
                image: "https://res.cloudinary.com/dvd1gjjou/image/upload/t_crop/v1743402597/closeup_wrong_jkzrl0.jpg",
                description: "ไก่"
            },
            {
                image: "https://res.cloudinary.com/dvd1gjjou/image/upload/t_crop/v1743403624/dog_wrong_xkydfl.jpg",
                description: "ห่งๆ"
            },
            {
                image: "https://res.cloudinary.com/dvd1gjjou/image/upload/t_crop/v1743403624/cat6_wrong_gnlwqa.jpg",
                description: "แมวs"
            }
        ],
        correctCatIndex: 0  // BEAN
    }
};

// Create a copy of the original data to work with
let gameData = JSON.parse(JSON.stringify(originalGameData));

let currentLevel = 1;
let currentCatIndex = 0;
let maxLevel = 2;

// DOM elements
const catImage = document.getElementById('cat-image');
const catDescription = document.getElementById('cat-description');
const rejectBtn = document.getElementById('reject-btn');
const likeBtn = document.getElementById('like-btn');
const catCard = document.getElementById('cat-card');
const levelIndicator = document.querySelector('.level-indicator');
const levelComplete = document.querySelector('.level-complete');
const nextLevelBtn = document.getElementById('next-level-btn');
const successScreen = document.querySelector('.success-screen');
const finalMessage = document.getElementById('final-message');
const swipeLeft = document.getElementById('swipe-left');
const swipeRight = document.getElementById('swipe-right');
const incorrectOverlay = document.getElementById('incorrect-overlay');
const incorrectScreen = document.querySelector('.incorrect-screen');
const retryBtnElement = document.getElementById('retry-btn'); // Modified variable name for clarity
const restartBtn = document.getElementById('restart-btn');
const dailyLimitReachedScreen = document.querySelector('.daily-limit-reached');

// Local Storage Keys
const GAME_DATA_KEY = 'catGameData';
const LAST_PLAYED_DATE_KEY = 'lastPlayedDate';
const MAX_TRIES = 3;

// DEBUG MODE (Set to TRUE to disable the daily limit)
const DEBUG_MODE = false;

// Initialize Game Function
function initGame() {
    // Check daily limit before initializing the game
    if (DEBUG_MODE === false && isDailyLimitReached()) {
        showDailyLimitReachedScreen();
    } else {
        // Initialize the game only if the daily limit is not reached
        shuffleCats();
        updateCatDisplay();
        setupEventListeners();
    }
}

// Daily Limit Check Function
function isDailyLimitReached() {
    const lastPlayedDate = localStorage.getItem(LAST_PLAYED_DATE_KEY);
    const today = new Date().toDateString();
    let tries = 0;

    // If the last played date is different from today, reset the number of tries
    if (lastPlayedDate !== today) {
        tries = 0;
        localStorage.removeItem(GAME_DATA_KEY);  // Clear previous day's tries
        localStorage.setItem(LAST_PLAYED_DATE_KEY, today);  // Start with today's date
    } else {
        // Get the number of tries from local storage
        const triesStr = localStorage.getItem(GAME_DATA_KEY);
        tries = triesStr ? parseInt(triesStr, 10) : 0;
    }

    // If the number of tries is greater than or equal to the maximum number of tries, show the daily limit reached screen
    if (tries >= MAX_TRIES) {
        return true;
    }

    return false;
}

// Increment tries function
function incrementTries() {
    let tries = 0;
    const lastPlayedDate = localStorage.getItem(LAST_PLAYED_DATE_KEY);
    const today = new Date().toDateString();

    // If the last played date is different from today, reset the number of tries
    if (lastPlayedDate !== today) {
        tries = 0;
        localStorage.removeItem(GAME_DATA_KEY);  // Clear previous day's tries
    } else {
        // Get the number of tries from local storage
        const triesStr = localStorage.getItem(GAME_DATA_KEY);
        tries = triesStr ? parseInt(triesStr, 10) : 0;
    }

    tries++;
    localStorage.setItem(GAME_DATA_KEY, tries.toString());  // Store updated tries

    return tries;
}

// Function to Show the Daily Limit Reached Screen
function showDailyLimitReachedScreen() {
    // Disable all interactive elements
    const gameContainer = document.querySelector('.game-container');
    gameContainer.classList.add('disabled');

    // Hide other screens
    hideAllScreens();

    // Show the daily limit reached screen
    dailyLimitReachedScreen.style.display = 'flex';

    // Remove event listeners to prevent gameplay
    removeEventListeners();
}

// Function to hide all screens
function hideAllScreens() {
    successScreen.style.display = 'none';
    levelComplete.style.display = 'none';
    incorrectScreen.style.display = 'none';
    dailyLimitReachedScreen.style.display = 'none';
}

// Function to setup all the event listeners
function setupEventListeners() {
    rejectBtn.addEventListener('click', rejectBtnClick);
    likeBtn.addEventListener('click', likeBtnClick);
    nextLevelBtn.addEventListener('click', goToNextLevel);
   retryBtnElement.addEventListener('click', retryLevel); // Now attach the event listener to the 'retry-btn'
    restartBtn.addEventListener('click', restartGame);

    // Mouse events for PC swiping
    catCard.addEventListener('mousedown', startDrag);
    document.addEventListener('mousemove', drag);
    document.addEventListener('mouseup', endDrag);

    // Touch events for mobile swiping
    catCard.addEventListener('touchstart', startDrag);
    document.addEventListener('touchmove', drag);
    document.addEventListener('touchend', endDrag);
}

// Remove Event Listeners
function removeEventListeners() {
    rejectBtn.removeEventListener('click', rejectBtnClick);
    likeBtn.removeEventListener('click', likeBtnClick);
    nextLevelBtn.removeEventListener('click', goToNextLevel);
    retryBtnElement.addEventListener('click', retryLevel);// Now remove the event listener to the 'retry-btn'
    restartBtn.addEventListener('click', restartGame);
    catCard.removeEventListener('mousedown', startDrag);
    document.removeEventListener('mousemove', drag);
    document.removeEventListener('mouseup', endDrag);
    catCard.removeEventListener('touchstart', startDrag);
    document.removeEventListener('touchmove', drag);
    document.removeEventListener('touchend', endDrag);
}

// rejectBtnClick Function
function rejectBtnClick() {
    handleChoice(false);
}

// likeBtnClick Function
function likeBtnClick() {
    handleChoice(true);
}

// Shuffle the cats for each level
function shuffleCats() {
    const levels = Object.keys(gameData);

    levels.forEach(level => {
        const cats = [...gameData[level].cats];
        const correctCat = cats[gameData[level].correctCatIndex];

        // Shuffle the array
        for (let i = cats.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [cats[i], cats[j]] = [cats[j], cats[i]];
        }

        // Update the data
        gameData[level].cats = cats;

        // Find the new index of the correct cat
        gameData[level].correctCatIndex = cats.findIndex(cat =>
            cat.description === correctCat.description
        );
    });
}

// Update cat display
function updateCatDisplay() {
    const level = `level${currentLevel}`;
    const catData = gameData[level].cats[currentCatIndex];

    catImage.src = catData.image;
    catDescription.textContent = catData.description;
    levelIndicator.textContent = `Level ${currentLevel}`;
    resetCardPosition(); // Ensure card starts at original position for each new card
}

// Start drag
function startDrag(e) {
    isDragging = true;
    cardWidth = catCard.offsetWidth;

    // Get start position
    if (e.type === 'mousedown') {
        startX = e.clientX;
    } else if (e.type === 'touchstart') {
        startX = e.touches[0].clientX;
    }

    // Reset transform
    catCard.style.transition = 'none';

    // Prevent default behavior
    e.preventDefault();
}

// Drag
function drag(e) {
    if (!isDragging) return;

    // Get current position
    if (e.type === 'mousemove') {
        currentX = e.clientX;
    } else if (e.type === 'touchmove') {
        currentX = e.touches[0].clientX;
    }

    // Calculate drag distance
    const dragDistance = currentX - startX;

    // Apply transform
    catCard.style.transform = `translateX(${dragDistance}px) rotate(${dragDistance * 0.03}deg)`;

    // Show swipe indicator
    if (dragDistance < -50) {
        swipeLeft.style.opacity = Math.min(-dragDistance / 100, 0.8);
        swipeRight.style.opacity = 0;
    } else if (dragDistance > 50) {
        swipeRight.style.opacity = Math.min(dragDistance / 100, 0.8);
        swipeLeft.style.opacity = 0;
    } else {
        swipeLeft.style.opacity = 0;
        swipeRight.style.opacity = 0;
    }
}

// End drag
function endDrag() {
    if (!isDragging) return;
    isDragging = false;

    // Calculate drag distance
    const dragDistance = currentX - startX;
    const swipeThreshold = cardWidth * 0.3;

    // Reset indicators
    swipeLeft.style.opacity = 0;
    swipeRight.style.opacity = 0;

    // Apply transition
    catCard.style.transition = '0.3s ease';

    // Handle swipe
    if (dragDistance < -swipeThreshold) {
        // Swiped left (reject)
        catCard.style.transform = `translateX(-${cardWidth}px) rotate(-30deg)`;
        setTimeout(() => handleChoice(false), 300);
    } else if (dragDistance > swipeThreshold) {
        // Swiped right (like)
        catCard.style.transform = `translateX(${cardWidth}px) rotate(30deg)`;
        setTimeout(() => handleChoice(true), 300);
    } else {
        // Reset position
        resetCardPosition(); // If not swiped far enough, reset position
    }
}

// Reset card position
function resetCardPosition() {
    catCard.style.transition = '0.3s ease';
    catCard.style.transform = 'translateX(0) rotate(0)';
}

// Handle user choice
function handleChoice(isLike) {
    const level = `level${currentLevel}`;
    const currentLevelData = gameData[level];

    // Check if correct cat
    if (isLike && currentCatIndex === currentLevelData.correctCatIndex) {
        // Correct guess
        showLevelComplete();
        return;
    } else if (isLike) {
        // Wrong guess (user thought this was the correct cat)
        showIncorrectGuess();
        return;
    }

    // Move to next cat
    currentCatIndex = (currentCatIndex + 1) % currentLevelData.cats.length;

    // Apply animation
    catCard.style.transform = 'translateX(-100%)';
    catCard.style.opacity = '0';
    catCard.style.transition = '0.3s ease';

    setTimeout(() => {
        updateCatDisplay();
        resetCardPosition(); // Reset card's position after transition
        catCard.style.transform = 'translateX(0)';
        catCard.style.opacity = '1';
    }, 300);
}

// Show incorrect guess feedback
  function showIncorrectGuess() {
    // Select the card and buttons elements
    const cardElement = document.querySelector('.card');
    const buttonsElement = document.querySelector('.buttons');

    // Add the 'none' display style if elements have been found.
    if (cardElement) {
        cardElement.style.display = 'none';
    }

    if (buttonsElement) {
        buttonsElement.style.display = 'none';
    }
    // Show incorrect overlay
    incorrectOverlay.style.opacity = '1';
    catCard.classList.add('shake');

    // Hide after a delay
    setTimeout(() => {
        incorrectOverlay.style.opacity = '0';
        catCard.classList.remove('shake');

        // Show incorrect screen
        hideAllScreens();
        incorrectScreen.style.display = 'flex';
        resetCardPosition(); // Reset card's position after showing incorrect screen
    }, 1000);
}

// Show level complete screen
function showLevelComplete() {
    const gameElements = document.querySelectorAll('.card, .buttons');
    gameElements.forEach(el => el.style.display = 'none');

    if (currentLevel < maxLevel) {
        levelComplete.style.display = 'flex';
    } else {
        successScreen.style.display = 'flex';
    }
    resetCardPosition(); // Reset card's position after showing level complete screen
}

// Go to next level
function goToNextLevel() {
    currentLevel++;
    currentCatIndex = 0;

    levelComplete.style.display = 'none';

    const gameElements = document.querySelectorAll('.card, .buttons');
    gameElements.forEach(el => el.style.display = '');

    updateCatDisplay();
    resetCardPosition(); // Reset card's position after going to next level
}

 // Retry current level
function retryLevel() {
    //Again, if it's debug mode skip this
    if (DEBUG_MODE === true) {
        console.log("DEBUG MODE: retry level logic without tries incremented.");
    }
    //Otherwise is this game even enabled?
    else {
        const gameContainer = document.querySelector('.game-container');
        if (gameContainer.classList.contains('disabled')) {
            return;  // Exit early if the game is disabled
        }
         //Now we increment the tries
        let tries = incrementTries();

        // Then Check Limit
        if (tries > MAX_TRIES) {
            showDailyLimitReachedScreen();
            return; // Important: Exit after reaching the limit
        }
    }

    // Reset data for current level
    gameData = JSON.parse(JSON.stringify(originalGameData));
    shuffleCats();

    // Reset UI
    const cardElement = document.querySelector('.card'); // Get card and buttons
    const buttonsElement = document.querySelector('.buttons');
    if (cardElement) {
        cardElement.style.display = '';//Reset card and button
    }
    if (buttonsElement) {
        buttonsElement.style.display = '';
    }
    currentCatIndex = 0;
    hideAllScreens();
    incorrectScreen.style.display = 'none';

    const gameElements = document.querySelectorAll('.card, .buttons');
    gameElements.forEach(el => el.style.display = '');

    updateCatDisplay();
    resetCardPosition(); // Reset card's position after retrying the level
}

// Restart game
function restartGame() {
    // Reset all data
    gameData = JSON.parse(JSON.stringify(originalGameData));
    shuffleCats();

    // Reset UI
    currentLevel = 1;
    currentCatIndex = 0;
    successScreen.style.display = 'none';

    const gameElements = document.querySelectorAll('.card, .buttons');
    gameElements.forEach(el => el.style.display = '');

    updateCatDisplay();
    resetCardPosition(); // Reset card's position after restarting the game
}

// Initialize the game when the page loads
window.addEventListener('DOMContentLoaded', initGame);